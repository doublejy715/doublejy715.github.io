---
title: DFS problem
author: Chris
layout: post
icon: fa-lightbulb
icon-style: regular
---
## 빙산(No. 2573)

### 조건

1. 동서남북 네 방향의 0이 저장된 칸의 개수만큼 줄어든다.
2. 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 
3. 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오

### 생각

1. check라는 행렬을 통해서 해당 년도의 빙하가 녹을 숫자를 체크한다.
2. 기존 maps에서 check의 값 만큼 빼 주고 BFS,  DFS를 돌려 몇 덩어리로 분리되어 있는지 체크한다.

### 예외

1. 만약 모든 maps이 0이 될 때까지(모두 녹을때 까지) BFS, DFS호출 개수가 1이면 결과는 0 이다.
2. BFS, DFS를 먼저 돌려 봄으로써 시간이 지나지 않고 바로 덩어리 진 상태를 체크한다.
3. BFS, DFS를 2번 호출하게 되면 도중에 끊어도 되는가?

### 코드 작성
#### 첫 코드
 - 시간초과 발생
 
``` python
import sys
read = sys.stdin.readline

def map_check():
    counts = 0

    for i in range(N):
        for j in range(M):
            if maps[i][j]:
                counts += 1

    return counts

# DFS
def DFS(year):
    count = 0
    visited = [[0]*M for _ in range(N)]

    for i in range(N):
        for j in range(M):
            if maps[i][j] and not visited[i][j]:
                count += 1
                need_visit = [[i,j]]

                while need_visit:
                    now = need_visit.pop(0)
                    visited[now[0]][now[1]] = 1

                    for k in range(4):
                        next_y, next_x = now[0] + dy[k], now[1] + dx[k]
                        if maps[next_y][next_x] and not visited[next_y][next_x] and not [next_y,next_x] in need_visit:
                            need_visit.append([next_y,next_x])

    return count, year+1


""" Input """
N,M = map(int,read().strip().split())
maps = [list(map(int,read().strip().split())) for _ in range(N)]
check = [[0]*M for _ in range(N)]


""" Solve """
dy, dx = (0,-1,0,1),(1,0,-1,0)
years = -1

while True:
    result,years = DFS(years)

    if result >= 2:
        print(years)
        break

    elif not map_check():
        print(0)
        break

    else:
        for i in range(N):
            for j in range(M):
                if maps[i][j]:
                    zero_count = 0
                    for k in range(4):
                        next_dy,next_dx = i+dy[k],j+dx[k]
                        if 0 <= next_dy < N and 0 <= next_dx < M and not maps[next_dy][next_dx]:
                            zero_count += 1
                    check[i][j] = zero_count

        for i in range(N):
            for j in range(M):
                if maps[i][j] - check[i][j] < 0:
                    maps[i][j] = 0
                else:
                    maps[i][j] -= check[i][j]

```

#### 재 시도
## 다리 만들기(No. 2146)
### 조건

1. 다른 대륙끼리의 다리를 최소 길이가 되도록 건설한다.
2. 다리의 위치가 아닌 다리의 길이를 출력한다.


### 생각
1. 대륙을 DFS or BFS로 구분해 준다.
2. 적어도 사방에 1개 이상의 0이 있는 곳에서 탐색을 적용한다. --> 굳이 안해줘도 시간내에 해결 가능했다.
3. 탐색을 실시하고 다른 섬을 만날 때 까지 길이를 잰다.
4. 최소를 찾는다.

### 최소화
1. 대륙을 그냥 구분하는 방법은 없는건가?(DFS를 2중으로 적용하기 싫음) --> 시간상 괜찮은가?
2. 최소보다 더 긴 경우 알아서 탈출하게 만든다.
3. 다리 표시는 -1 로 한다.

### 코드
#### 첫 코드
```
import sys
input = sys.stdin.readline

def DFS_Solve(y,x,count=0,visited=None):
    if not visited:
        visited = set()

    for i in range(4):



def Map_Remake():
    global maps
    maps_check = [[0]*N for _ in range(N)]
    count = 0

    for i in range(N):
        for j in range(N):
            if maps[i][j] and not maps_check[i][j]:
                count += 1
                need_visit = [[i,j]]

                while need_visit:
                    now = need_visit.pop(0)
                    maps[now[0]][now[1]] = count
                    maps_check[now[0]][now[1]] = 1

                    for k in range(4):
                        next_y,next_x = now[0] + dy[k],now[1] + dx[k]
                        if 0 <= next_y < N and 0 <= next_x < N and maps[next_y][next_x] and not maps_check[next_y][next_x]:
                            need_visit.append([next_y,next_x])

""" Input & setting """
N = int(input())
maps = [list(map(int,input().split())) for _ in range(N)]

dy,dx = (0,-1,0,1),(1,0,-1,0)
Map_Remake()
print(maps)

""" Solve """

for i in range(N):
    for j in range(N):
        if maps[i][j]:
            for k in range(4):
                next_y, next_x = i + dy[k], j + dx[k]
                if not maps[next_y][next_x]:
                    result = DFS_Solve(next_y,next_x)
```

#### 완성 코드
```
from collections import deque
import sys
read = sys.stdin.readline

def DFS(y,x,visit):
    queue = deque([[y,x]])
    melting_point = deque()
    visit[y][x] = 1

    while queue:
        now_y,now_x = queue.popleft()
        melt = 0

        for k in range(4):
            next_y, next_x = now_y + dy[k], now_x + dx[k]
            if 0 <= next_y < N and 0 <= next_x < M and visit[next_y][next_x] == 0:
                if maps[next_y][next_x] != 0:
                    visit[next_y][next_x] = 1
                    queue.append([next_y,next_x])
                else:
                    melt += 1
        if melt != 0 and [now_y,now_x,melt] not in melting_point:
            melting_point.append([now_y,now_x,melt])

    return melting_point


""" Input """
N, M = map(int, read().strip().split())
maps = [list(map(int, read().strip().split())) for _ in range(N)]


""" Solve """
dy, dx = (0, -1, 0, 1), (1, 0, -1, 0)
years = 0

while True:
    count = 0
    visit = [[0] * M for _ in range(N)]

    for y in range(N):
        for x in range(M):
            if maps[y][x] and visit[y][x] == 0:
                count += 1
                melt_point = DFS(y,x,visit)
                while melt_point:
                    m_y,m_x,melt = melt_point.popleft()
                    maps[m_y][m_x] = max(maps[m_y][m_x]-melt,0)

    if count == 0:
        years = 0
        break

    if count >= 2:
        break

    years += 1

print(years)
```


### 의문점
1. 왜 deque함수를 쓰는 것인가? / list의 pop(0)와 append를 이용하면 충분하지 않는가?

## 이분 그래프(No. 1707)
### 조건
입력으로 그래프가 주어지면, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.

### 입력
테스트 케이스의 수 : 2 <= K <= 5
정점의 개수 : 1 <= V <= 20000
간선의 개수 : 1 <= E <= 200000

### 코드
#### 완성 코드
```
from collections import deque
import sys
input = sys.stdin.readline

""" Input """
tc = int(input())
for _ in range(tc):
    V, E = map(int,input().strip().split())
    graph = [[] for _ in range(V+1)]
    for __ in range(E):
        v1,v2 = map(int,input().strip().split())
        graph[v1].append(v2)
        graph[v2].append(v1)

    color = [0]*(V+1)
    STOP = False

    """ Solve """
    for i in range(1,V+1):
        # 기저조건
        if STOP: break
        if color[i] > 0 : continue

        color[i] = 1
        q = deque([i])

        while q and not STOP:
            now = q.popleft()
            c = 3 - color[now]

            for j in graph[now]:
                if not color[j]:
                    q.append(j)
                    color[j] = c
                elif color[now] == color[j]:
                    STOP = True
                    break

    print("YES" if not STOP else "NO")
```

