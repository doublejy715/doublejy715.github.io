---
title: Develop info
subtitle: I will begin my project.
layout: "page"
icon: fa-book
order: 3
---
---
## Table of Contents

1. [Graph](#Graph)
   1. [Graph도입](#Graph도입)

2. [DFS](#DFS)
   1. [Graph도입](#Graph도입)
---




---
## Brute-Force
### 1.1 도입
컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 의미합니다. 가능한 방법을 전부 만들어 보는 알고리즘들을 가리켜 흔히 완전 탐색(exhaustive search)이라고 부릅니다.

### 1.2 재귀 호출과 완전 탐색
1. 재귀 호출

	자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수를 가리킵니다. 모든 재귀 함수는 '더이상 쪼개지지 않는' 최소한의 작업'에 도달했을 때 답을 **곧장 반환하는 조건문을 포함**해야 합니다. 이때 쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 **기저사례(base case)** 라고 합니다. 기저 사례를 선택할 때는 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록 신경써야 합니다.
	
	- 예제 : 중첩 반복문 대체하기
	
		0번부터 n개의 원소 중 네 개를 고르는 모든 경우
 		```
 		for i in range(n):
 			for j in range(i,n):
 				for k in range(j,n):
 					for l in range(k,n):
 						print(i,j,k,l)
 		```
 		
 		재귀함수를 이용한 경우
 		
 		
2. 시간 복잡도 분석
 
	 가능한 후보의 수를 전부 세어 보기만 하면 된다.
	
3. 완전 탐색 레시피

	어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정은 다음과 같습니다.
	
		1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례합니다. 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지를 가늠합니다. 		2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눕니다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 됩니다.
		3. 그 중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성합니다.
		4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 기저 사례로 선택해 처리합니다.

		
## 동적 계획법
### 1.1 도입
#### 1. 중복되는 부분 문제

동적 계획법을 큰 의미에서 분할 정복과 같은 접근 방식을 의미합니다. 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원ㄹ내 문제에 대한 답을 계산해 내기 때문입니다.

동적 계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식입니다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수있습니다. 

## Graph
### 1.1 Graph 도입
#### 1. graph의 정의

그래프 G(V,E)는 어떤 자료나 개념을 표현하는 정점(vertex)들의 집합 C와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료 구조입니다.

그래프는 정점들과 간선들로 정의되며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않습니다.

#### 2. graph의 종류
그래프는 표현하고자 하는 대상에 따라 여러가지 변형된 형태를 가질 수 있습니다. 이들은 정점이나 간선에 추가적 속성을 부여할 수도 있고, 존재할 수 있는 간선이나 정점의 형태에 제약을 두기도 합니다.

	1) 간선과 정점의 형태
		방향 그래프(directed graph)
		무향 그래프(undirected graph)
		가중치 그래프(weighted graph)
		
	2) 그래프의 형태
		다중그래프(multi graph) : 두 정점 사이에 두 개 이상의 간선이 있는 수 있는 그래프
		단순그래프(simple graph) : 두 정점 사이에 최대 한개의 간선만 있는 그래프
		루트 없는 트리(unrooted tree) : 부모 자식 관계가 없음
		이분 그래프(biparite graph) : 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프
		사이클 없는 방향 그래프(DAG, directed acyclic graph)
		
	[그림. 27.2]
	
#### 3. graph의 경로

경로 : 끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것.

 - 단순경로(simple path) : 경로 중 한 정점을 최대 한 번만 지나는 경로
 > ex) 2 -> 3 -> 4 -> 2 -> 5은 2를 두 번 지나가기 때문에 단순 경로가 아니다.
	
 - 사이클(cycle) : 시작한 점에서 끝나는 경로
	
#### 4. graph의 표현 방법
여러 객체들이 서로 연결되어 있다는 점에서 그래프는 트리와 별로 다를 것이 없습니다. 많은 경우 그래프는 트리에 비해 훨씬 정적인 용도로 사용됩니다. 정적이라는 말은 새로운 정점이나 간선을 추가하고 삭제하는 일이 자주 일어나지 않는다는 의미입니다. 따라서 대부분 그래프는 구조의 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현하곤 합니다.

 - 인접 리스트 표현(adjacency list)

	인접 리스트 표현은 그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현합니다.  따라서 그래프는 각 정점마다 하나의 연결 리스트를 갖는 방식으로 구현됩니다.
	
	```
	for i in range(N):
		graph[i].append(list(map(int,input().split())))	# i번째에 해당하는 노드에 다른 이어진 노드의 번호를 달아놓는다.
	```
	

	단점은 두 정점이 주어질. 때 이 정점이 연결되어 있는지를 알기 위해서는 연결 리스트를 일일이 뒤져야 한다는 것입니다.

- 인접 행렬 표현(adjacency matrix)

	앞의 인접 리스트 표현에서 연산의 속도를 높이기 위해 고안된 그래프 표현 방식이 인접 행렬 표현입니다. 그래프의 인접 행렬 표현은 V * V 크기의 행렬, 즉. 2차원 배열을 이용해 그래프의 간선 정보를 저장합니다.

	```adjacency_list = [[0]*N for _ in range(N)]```

	파이썬에서는 위와 같이 2차원 배열의 형태로 인접 행렬 그래프를 표현합니다.

- 인접 행렬 표현과 인접 리스트 표현의 비교

	인접 행렬 표현의 장점 : 정점의 번호 u,v가 주어졌을 때 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인할 수 있다는 것입니다.

	인접 행렬 표현의 단점 : 인접 행렬 표현은 V * V 크기의 2차원 배열을 사용하기 때문에, 실제 간선의 개수와 관계없이 항상 O(V^2) 크기의 공간을 사용한다는 문제점이 존재한다.
	
	인접 리스트 표현의 장점 : 전체 O(V + E)의 공간만을 이용한다.
	
	인접 리스트 표현의 단점 : 간선 (u,v)가 존재하는지 확인하기 위해서는 연결 리스트 adjacency_list[u]의 모든 원소를 일일이 확인해야 합니다.
	
## DFS(깊이 우선 탐색)
### 2.1 DFS도입
트리의 순회와 같이 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘들을 그래프의 탐색(search) 알고리즘이라고 합니다. 그래프는 트리보다 구조가. 훨씬 복잡할 수 있기 떄문에 탐색 과정에서 얻어지는 정보가 아주 중요합니다. 탬색 과정에서 어떤 간선이 사용되었는지, 또 어떤 순서로 정점들이 방문되었는지를 통해 그래프의 구조를 알 수 있습니다.

과정 : 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법입니다. 현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라가는 것이다. 이 과정에서 더이상 갈 곳이 없는 막힌 정점에 도달하면 포기하고, 마지막에 따라왔던 간선을 따라 뒤로 돌아갑니다.

깊이 우선 탐색은 탐색의 각 과정에서 가능한 한 그래프 안으로 '깊이' 들어가려고 시도하며, 막힌 정점에 도달하지 않는 한 뒤로 돌아가지 않습니다.

### 2.2 DFS의 구현
DFS는 주로 2가지 방법으로 구현됩니다. 첫번째는 stack(스택)을 이용한 방법, 두번쨰는 재귀 호출을 이용한 방법이 존재합니다.

#### 1. stack을 이용한 방법
```
def DFS(graph, root):
	visited = []
	stack = [root]
	
	while stack:								# stack이 빌때 까지 탐색 진행
		vertex = stack.pop()
		if vertex not in visited :				# 방문 여부를 검색
			visited.append(vertex)
			stack.extend(graph[vertex] - visited)	# 방문하지 않은 vertex를 stack에 저장
	
	return visited
```

#### 2. 재귀 호출을 이용한 방법
```
def DFS_recursive(graph, root, visited=None):
	if visited is None:							# 만약 처음 시작한다면 visited 형성
		visited = set() 							# 반복 방문할 수 있으므로 set으로 visited 지정

	visited.add(root)	
	
	for node in graph[root] - visited :				#  방문하지 않은 vertex에 한해서 node들을 방문한다.
		DFS_recursive(graph, node, visited)
		
	return visited
```
**Q. stack 과 재귀 호출을 적재적소에 사용하는 방법은?**

#### 3. 깊이 우선 탐색의. 시간 복잡도
- 인접 리스트를 사용해 그래프를 표현하는 경우

	dfs()는 한 정점마다 한 번씩 호출되므로, 정확히 V번 호출됩니다. 모든 정점에 대해. dfs()를 수행하고 나면 모든 간선을 정확히 한번(방향 그래프의 경우) 혹은 두 번(무향 그래프의 경우) 확인함을 알 수 있습니다. 따라서 깊이 우선 탐색의 시간 복잡도는 O(V+E)가 됩니다.
	
- 인접 행렬을 사용하는 경우
	
	이 경우에도 dfs()의 호출 횟수는 그대로 V번입니다. 하지만 인접 행렬을 사용할 때는 dfs() 내부에서 다른 모든 정점을 순회하며 두 정점 사이에 간선이 있는가를 확인해야 하기 때문에 한 번의 실행에 O(V)의 시간이 든다. 따라서 전체 시간 복잡도는 O(V^2)이 됩니다.
	
## BFS(너비 우선 탐색)
### 3.1 BFS도입
너비 우선 탐색은 깊이 우선 탐색과 함께 그래프 탐색 방식의 두 축을 이룹니다. 다익스트라의 최단 거리 알고리즘이나 프림의 최소 스패닝 트리 알고리즘 등이 너비 우선 탐색을 골격으로 하고 있습니다.

너비 우선 탐색의 동작 과정은 시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘이다.

### 3.2 BFS 과정
	1. 모든 인접 정점들을 검사합니다.
	2. 이 중 처음 보는 정점을 발견하면 이 정점을 방문 예정이라고 기록해 둔 뒤, 별도의 위치에 저장합니다.
	3. 인접한 정점을 모두 검사하고 나면, 지금까지 저장한 목록에서 다음 정점을 꺼내서 방문하게 됩니다.

### 3.3 BFS의 구현
큐를 이용하여 방문할 곳을 목록화 한다.

```
def BFS(A):
	queue = []
	visited = set()
	
	while queue:
		node = queue.pop()
		if node not in visited:
			queue.extend(graph[node])			# 현재 노드와 연결된 노드의 목록을 queue 목록에 넣어준다.
```

### 3.4 너비 우선 탐색의 시간 복잡도

- 인전 리스트로 구현된 경우 : O(V+E)
- 인접 행렬로 구현했을 경우 : O(V^2)

### 3.5 너비 우선 탐색과 최단 거리

그래프의 구조에 관련된 다야한 문제를 푸는데 사용되는 깊이 우선 탐색과 달리, 너비 우선 탐색은 대개 딱 하나의 용도로 사용됩니다. 바로 그래프에서의 **최단 경로 문제**를 푸는 것입니다. 

## 이분 그래프
### 이분 그래프란?
인접한 정점끼리 서로 다른 색으로 칠해서 모든 정점을 두 가지 색으로만 칠할 수 있는 그래프를 말한다.
즉 , 그래프의 모든 정점이 두 그룹으로 나눠지고 **서로 다른 그룹의 정점이 간선으로 연결된 그래프**를 이분 그래프라고 한다.

### 이분 그래프의 특징
- 이분 그래프인지 확인하기 위해서 BFS, DFS 같은 그래프 탐색 방법을 이용할 수 있다.
- 특히, BFS를 이용할 경우에는 같은 레벨의 정점끼리는 같은 색으로 칠해진다.
- 연결 요소의 개수를 구하는 방법과 유사하다.
- 모든 정점을 방문하며 간선을 검사하기 때문에 시간 복잡도는 O(V+E)로 그래프 탐색 알고리즘과 같다.

### 이분 그래프인지 확인하는 방법
서로 인접한 정점이 같은 색으로 칠해진다면 이분 그래프가 아니다.

1. 그래프 탐색(BFS, DFS)를 이용해 정점을 방문할 때마다 두 가지 색 중 다른색을 칠한다.
2. 다음 정점을 방문하면서 자신과 인접한 정점(간선으로 연결된 정점)은 자신과 다른 색으로 칠한다.
3. 탐색을 진행할 때, 자신과 인접한 정점의 색이 자신과 동일하면 이분 그래프가 아니다.
	- BFS의 경우, 정점을 방문하다가 만약 같은 레벨에서 정점을 다른 색으로 칠해야 한다면 이는 이분 그래프가 아니다.
4. 모든 정점을 방문했는데, 위의 경우가 없다면 이분 그래프이다.

**주의점 : 연결 그래프와 비연결 그래프 모두 고려해야 한다는 것이다. 그래프가 비연결 그래프인 경우에는 모든 정점에 대해서 확인하는 작업이 필요하다.**

### 코드[python]
BFS를 이용

```

from collections import deque
import sys

for tc in range(int(sys.stdin.readline())):
    # input, vertex, edge를 받아낸다.
    v, e = map(int, sys.stdin.readline().split())
    link = [[] for _ in range(v+1)]

    for _ in range(e):
        a, b = map(int, sys.stdin.readline().split())
        link[a].append(b)                               # 양방향 그래프로 표현
        link[b].append(a)

    color = [0] * (v+1)                                 # color marking
    STOP = False
    for i in range(1, v+1):                             # vertex를 한개씩 방문하면서
        # 기저조건(stop해야 하는지, 이미 기록되어 있는지)
        if STOP : break
        if color[i] > 0: continue

        # 반드시 시작점은 1의 팀에 넣어준다.(분리되어있는 graph일 수 있으므로)
        color[i] = 1
        queue = deque([i])

        # 큐 스케줄이 존재하고, STOP = True일 때(?) 진행
        while queue and not STOP:
            q = queue.popleft()
            c = 3 - color[q]                            # 이분 그래프 팀 기록을 위함
            
            # 해당 vertex와 견결되어 있는 모든 vertex를 색칠 & queue에 넣어준다.
            for l in link[q]:
                if color[l] == 0:
                    color[l] = c
                    queue.append(l)
                elif color[l] == color[q]:              # 그만두는 조건 : 현재 vertex와 다음 vertex의 색이 같을 경우
                    STOP = True
                    break

    print("YES" if not STOP else "NO")

```



## 데이터 구조 : 큐(Queue)
### 큐 란?
- 줄을 서는 행위와 유사하다 할 수 있다.
- 가장 먼저 넎은 데이터를 가장 먼저 꺼낼 수 있는 구조

	> 음식점에서 가장 먼저 줄을 선 사람이 제일 먼저 음식점에 입장하는 것과 동일
	
	> FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식으로 스택과 꺼내는 순서가 반대
	
### 알아둘 용어
- Enqueue : 큐에 데이터를 넣는 기능
- Dequeue : 큐에서 데이터를 꺼내는 기능

### 파이썬 queue 라이브러리 활용에서 큐 자료 구조 사용하기
- queue 라이브러리에는 다양한 큐 구조로 Queue, LifoQueue, PriorityQueue 제공
	- Queue() : 가장 일반적인 큐 자료 구조
	- LifoQueue() : 나중에 입력된 데이터가 먼저 출력되는 구조 (스택과 유사 방식)
	- PriorityQueue() : 데이터마다 우선순위를 넣어서, 우선순위가 높은 순으로 데이터 출력

	
### 큐 코드

```
import queue

# 큐 만들기 : 이름(queue)
queue1 = queue.Queue()
queue2 = queue.LifoQueue()
queue3 = queue.PriorityQueue()

# 데이터 넣기
queue1.put("korea")
queue1.put(1)
queue2.put("She")
queue2.put(123)
queue3.put((10,"정영1"))			# (우선순위, 큐 내용)
queue3.put((13,"정영2"))

# 큐 사이즈 확인하기
print(queue1.qsize())
print(queue2.qsize())

# 데이터 꺼내기
print(queue1.get())
print(queue2.get())
print(queue3.get())				# 우선순위가 낮은 것부터 나온다.

```

## 최장 증가 수열[LIS]
### 의미
LIS는 앞에서부터 뒤로 숫자를 선택하며 부분 수열을 구성해 나갈 때 증가하는 순서대로 숫자를 고르면서 고른 부분 수열의 길이가 최대 길이가 되도록 숫자를 선택하는 경우.

- 시간복잡도 : O(N^2),O(NlogN)
- DP[x] : x번째 수를 마지막 원소로 가지는 lis의 길이로 지정한다.

### 코드
#### O(N^2)의 경우
 ```
 arr = [3, 1, 2, 4, 8, 6, 7]
dp = [1] * len(arr)

for i in range(1, len(arr)):                           # arr에서 두번째 원소부터 훑는다.
    for j in range(i):                                 
        if arr[j] < arr[i]:
            dp[i] = max(dp[i], dp[j] + 1)              # 자동적으로 이때까지의 가장 큰 부분 증가수열에 1을 더한 꼴이 될 것이다.

res = max(dp)
 ```
 
 
#### Lower bound
어떠한 정렬된 배열 arr에서 어떠한 값 val의 lower bound란 arr을 정렬된 상태로 유지하면서 val이 삽입될 수 있는 위치들 중 가장 인덱스가 작은 것이다.

가령 [1, 3, 3, 4, 6, 7]의 배열에서 1의 lower bound는 1이고, 3의 lower bound는 2 이며, 5의 lower bound는 4이다. (이 글에서 배열의 인덱스는 1부터 시작한다는 것에 유의해주세요). 또한 upper bound라는 개념도 있는데, 이것은 반대로 삽입될 수 있는 위치들 중 가장 인덱스가 큰 것이다.
 
이 lower bound는 이진 탐색을 통해 logN 시간에 구할 수 있다.

#### O(N log N)의 경우. *이건좀더!!!!*
O(N^2) 알고리즘은 i번째 원소 직전에 올 수 있는 원소들중 가장 길게 만들 수 있는 것을 찾을 때, 1 ~ i - 1 까지의 모든 원소를 순회합니다. 따라서 이 과정에 O(N)의 시간이 걸리게 되고, 전체 시간복잡도는 O(N^2)이 됩니다. O(N log N) 알고리즘은 이 과정을 **이진 탐색**을 통해 O(log N) 시간에 수행하고, 따라서 전체 시간복잡도는 O(N log N)이 됩니다. 

이 알고리즘은 다음과 같은 리스트 L을 업데이트하며 동작합니다. 
L[i] = 길이 i인 증가하는 부분 수열을 만들 수 있는 마지막 원소 중  가장 작은 값
따라서 L의 크기가 곧 현재까지 만들 수 있는 LIS의 길이이며, 처음에는 빈 리스트로 시작합니다.


