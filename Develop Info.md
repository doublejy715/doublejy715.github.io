---
title: Develop info
subtitle: I will begin my project.
layout: "page"
icon: fa-book
order: 3
---
---
## Table of Contents

1. [Graph](#Graph)
   1. [Graph도입](#Graph도입)

2. [DFS](#DFS)
   1. [Graph도입](#Graph도입)
---




---
## [1] Graph
### 1.1 Graph 도입
#### 1. graph의 정의

그래프 G(V,E)는 어떤 자료나 개념을 표현하는 정점(vertex)들의 집합 C와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료 구조입니다.

그래프는 정점들과 간선들로 정의되며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않습니다.

#### 2. graph의 종류
그래프는 표현하고자 하는 대상에 따라 여러가지 변형된 형태를 가질 수 있습니다. 이들은 정점이나 간선에 추가적 속성을 부여할 수도 있고, 존재할 수 있는 간선이나 정점의 형태에 제약을 두기도 합니다.

	1) 간선과 정점의 형태
		방향 그래프(directed graph)
		무향 그래프(undirected graph)
		가중치 그래프(weighted graph)
		
	2) 그래프의 형태
		다중그래프(multi graph) : 두 정점 사이에 두 개 이상의 간선이 있는 수 있는 그래프
		단순그래프(simple graph) : 두 정점 사이에 최대 한개의 간선만 있는 그래프
		루트 없는 트리(unrooted tree) : 부모 자식 관계가 없음
		이분 그래프(biparite graph) : 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프
		사이클 없는 방향 그래프(DAG, directed acyclic graph)
		
	[그림. 27.2]
	
#### 3. graph의 경로

경로 : 끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것.

 - 단순경로(simple path) : 경로 중 한 정점을 최대 한 번만 지나는 경로
 > ex) 2 -> 3 -> 4 -> 2 -> 5은 2를 두 번 지나가기 때문에 단순 경로가 아니다.
	
 - 사이클(cycle) : 시작한 점에서 끝나는 경로
	
#### 4. graph의 표현 방법
여러 객체들이 서로 연결되어 있다는 점에서 그래프는 트리와 별로 다를 것이 없습니다. 많은 경우 그래프는 트리에 비해 훨씬 정적인 용도로 사용됩니다. 정적이라는 말은 새로운 정점이나 간선을 추가하고 삭제하는 일이 자주 일어나지 않는다는 의미입니다. 따라서 대부분 그래프는 구조의 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현하곤 합니다.

 - 인접 리스트 표현(adjacency list)

	인접 리스트 표현은 그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현합니다.  따라서 그래프는 각 정점마다 하나의 연결 리스트를 갖는 방식으로 구현됩니다.
	
	```
	for i in range(N):
		graph[i].append(list(map(int,input().split())))	# i번째에 해당하는 노드에 다른 이어진 노드의 번호를 달아놓는다.
	```
	

	단점은 두 정점이 주어질. 때 이 정점이 연결되어 있는지를 알기 위해서는 연결 리스트를 일일이 뒤져야 한다는 것입니다.

- 인접 행렬 표현(adjacency matrix)

	앞의 인접 리스트 표현에서 연산의 속도를 높이기 위해 고안된 그래프 표현 방식이 인접 행렬 표현입니다. 그래프의 인접 행렬 표현은 V * V 크기의 행렬, 즉. 2차원 배열을 이용해 그래프의 간선 정보를 저장합니다.

	```adjacency_list = [[0]*N for _ in range(N)]```

	파이썬에서는 위와 같이 2차원 배열의 형태로 인접 행렬 그래프를 표현합니다.

- 인접 행렬 표현과 인접 리스트 표현의 비교

	인접 행렬 표현의 장점 : 정점의 번호 u,v가 주어졌을 때 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인할 수 있다는 것입니다.

	인접 행렬 표현의 단점 : 인접 행렬 표현은 V * V 크기의 2차원 배열을 사용하기 때문에, 실제 간선의 개수와 관계없이 항상 O(V^2) 크기의 공간을 사용한다는 문제점이 존재한다.
	
	인접 리스트 표현의 장점 : 전체 O(V + E)의 공간만을 이용한다.
	
	인접 리스트 표현의 단점 : 간선 (u,v)가 존재하는지 확인하기 위해서는 연결 리스트 adjacency_list[u]의 모든 원소를 일일이 확인해야 합니다.
	
## [2] DFS(깊이 우선 탐색)
### 2.1 DFS도입
트리의 순회와 같이 그래프의 모든 정점들을 특정한 순서에 따라 방문하는 알고리즘들을 그래프의 탐색(search) 알고리즘이라고 합니다. 그래프는 트리보다 구조가. 훨씬 복잡할 수 있기 떄문에 탐색 과정에서 얻어지는 정보가 아주 중요합니다. 탬색 과정에서 어떤 간선이 사용되었는지, 또 어떤 순서로 정점들이 방문되었는지를 통해 그래프의 구조를 알 수 있습니다.

과정 : 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법입니다. 현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라가는 것이다. 이 과정에서 더이상 갈 곳이 없는 막힌 정점에 도달하면 포기하고, 마지막에 따라왔던 간선을 따라 뒤로 돌아갑니다.

깊이 우선 탐색은 탐색의 각 과정에서 가능한 한 그래프 안으로 '깊이' 들어가려고 시도하며, 막힌 정점에 도달하지 않는 한 뒤로 돌아가지 않습니다.

### 2.2 DFS의 구현
DFS는 주로 2가지 방법으로 구현됩니다. 첫번째는 stack(스택)을 이용한 방법, 두번쨰는 재귀 호출을 이용한 방법이 존재합니다.

#### 1. stack을 이용한 방법
```
def DFS(graph, root):
	visited = []
	stack = [root]
	
	while stack:								# stack이 빌때 까지 탐색 진행
		vertex = stack.pop()
		if vertex not in visited :
			visited.append(vertex)				# 방문 여부를 검색
			stack.extend(graph[vertex] - visited)	# 방문하지 않은 vertex를 stack에 저장
	
	return visited
```

#### 2. 재귀 호출을 이용한 방법
```
def DFS_recursive(graph, root, visited=None):
	if visited is None:							# 만약 처음 시작한다면 visited 형성
		visited = set() 							# 반복 방문할 수 있으므로 set으로 visited 지정

	visited.add(root)	
	
	for node in graph[root] - visited :				#  방문하지 않은 vertex에 한해서 node들을 방문한다.
		DFS_recursive(graph, node, visited)
		
	return visited
```
**Q. stack 과 재귀 호출을 적재적소에 사용하는 방법은?**


